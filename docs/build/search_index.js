var documenterSearchIndex = {"docs":
[{"location":"api/#Public-Interface","page":"API","title":"Public Interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"When using ARTEMIS as a normal julia package with the exported functions we provide many methods for working with CRISPR gRNA and off-targets for your convenience.","category":"page"},{"location":"api/#Abstract-gRNA","page":"API","title":"Abstract gRNA","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"To encapsulate motifs that we search for on the genome, we can use abstract definition of gRNA/off-target, which is defined in Motif data structure.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Motif\nlength_noPAM\nsetdist\nsetambig","category":"page"},{"location":"api/#ARTEMIS.Motif","page":"API","title":"ARTEMIS.Motif","text":"Motif(\n    alias::String, \n    fwdmotif::String, \n    fwdpam::String, \n    forward_strand::Bool = true, \n    reverse_strand::Bool = true, \n    distance::Int = 4, \n    extends5::Bool = true,\n    ambig_max::Int = 5)\n\nMotif(alias::String)\n\nMotif defines what we search on the genome, what can be identified as an off-target.\n\nArguments\n\nalias - alias of the motif for easier identification e.g. Cas9\n\nfwdmotif - Motif that indicates where is PAM inside fwdpam.     For example for Cas9 it is 20*N + XXX: NNNNNNNNNNNNNNNNNNNNXXX\n\nfwdpam   - Motif in 5'-3' that will be matched on the reference (without the X).              For example for Cas9 it is 20*X + NGG:              XXXXXXXXXXXXXXXXXXXXNGG\n\nforward  - If false will not match to the forward reference strand.\n\nreverse  - If false will not match to the reverse reference strand.\n\ndistance - How many extra nucleotides are needed for a search? This              will indicate within what distance we can search for off-targets.              When we don't have those bases we use DNA_Gap.\n\nextend5  - Defines how off-targets will be aligned to the guides and where              extra nucleotides will be added for alignment within distance. Whether              to extend in the 5' and 3' direction. Cas9 is extend5 = true. ambig_max- How many ambiguous bases are allowed in the pattern?\n\nExample for Cas9 where we want to search for off-targets within distance of 4:\n  alias:    Cas9\n  fwdmotif: NNNNNNNNNNNNNNNNNNNNXXX\n  fwdpam:   XXXXXXXXXXXXXXXXXXXXNGG\n  forward:  true\n  reverse:  true\n  distance: 4\n  extend5:  true\n  ambig_max:5 \n\nAlignments will be performed from opposite to the extension direction (which is deifned by extend5).\n\nExamples\n\njulia> Motif(\"Cas9\")\nMotif(\"Cas9\", NNNNNNNNNNNNNNNNNNNNNGG, CCNNNNNNNNNNNNNNNNNNNNN, 21:23, 1:3, 3, true, 0)\n\njulia> Motif(\"test name\", \"NNNNNNNNNNNNNNNNNNNNXXX\", \"XXXXXXXXXXXXXXXXXXXXNGG\", true, true, 3, true, 5)\nMotif(\"test name\", NNNNNNNNNNNNNNNNNNNNNGG, CCNNNNNNNNNNNNNNNNNNNNN, 21:23, 1:3, 3, true, 5)\n\n\n\n\n\n","category":"type"},{"location":"api/#ARTEMIS.length_noPAM","page":"API","title":"ARTEMIS.length_noPAM","text":"length_noPAM(motif::Motif)\n\nCalculate what is the length of the motif, with extension, but without PAM. Effectively, size of the off-target on the genome.\n\nExamples\n\njulia> length_noPAM(Motif(\"Cas9\"))\n20\n\n\n\n\n\n","category":"function"},{"location":"api/#ARTEMIS.setdist","page":"API","title":"ARTEMIS.setdist","text":"setdist(motif::Motif, distance::Int)\n\nSet the distance (maximum value of allowed mismatches, deletion, insertions)  that are allowed during alignment.\n\nExamples\n\njulia> setdist(Motif(\"Cas9\"), 15)\nMotif(\"Cas9\", NNNNNNNNNNNNNNNNNNNNNGG, CCNNNNNNNNNNNNNNNNNNNNN, 21:23, 1:3, 15, true, 0)\n\n\n\n\n\n","category":"function"},{"location":"api/#ARTEMIS.setambig","page":"API","title":"ARTEMIS.setambig","text":"setambig(motif::Motif, ambig::Int)\n\nSet the ambiguity (how many ambigous bases are allowed) level for motif.\n\nExamples\n\njulia> setambig(Motif(\"Cas9\"), 15)\nMotif(\"Cas9\", NNNNNNNNNNNNNNNNNNNNNGG, CCNNNNNNNNNNNNNNNNNNNNN, 21:23, 1:3, 3, true, 15)\n\n\n\n\n\n","category":"function"},{"location":"api/#Find-off-targets","page":"API","title":"Find off-targets","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DBInfo\ngatherofftargets!","category":"page"},{"location":"api/#ARTEMIS.DBInfo","page":"API","title":"ARTEMIS.DBInfo","text":"DBInfo(filepath::String, name::String, motif::Motif; vcf_filepath::String = \"\")\n\nMotif defines what genome file is being used for searches.\n\nArguments\n\nfilepath - Path to the genome file, if file is fasta (ends with .fa or .fasta or .fna)  make sure you also have fasta index file with extension .fai. Alternatively, you can use .2bit  genome file.  \n\nname - Your name for this instance of DBInfo: the genome with connection to the motif and vcf file.\n\nmotif   - Motif object defining search parameters\n\nvcf_filepath  - Optional. Path to the VCF file to include in the searches.\n\nAlignments will be performed from opposite to the extension direction (which is deifned by extend5).\n\nExamples\n\n# use ARTEMIS example genome\ngenome = joinpath(\n    vcat(\n        splitpath(dirname(pathof(ARTEMIS)))[1:end-1], \n        \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n# construct example DBInfo\nDBInfo(genome, \"Cas9_semirandom_noVCF\", Motif(\"Cas9\"))\n\n\n\n\n\n","category":"type"},{"location":"api/#ARTEMIS.gatherofftargets!","page":"API","title":"ARTEMIS.gatherofftargets!","text":"gatherofftargets!(output::T, dbi::DBInfo) \n    where {T<:Union{Vector{String}, Vector{UInt64}, Vector{UInt128}}}\n\nGathers all off-targets that conform to the given dbi Motif.\n\nThis function appends to the output during the run, however it will also return all ambiguous  guides in return object. We use UInt64 and UInt128 to compress space that the gRNAs use. When using  large genomes or non-specific PAMs you might run out of memory when using this function.\n\nExamples\n\n# use ARTEMIS example genome\ngenome = joinpath(\n    vcat(\n        splitpath(dirname(pathof(ARTEMIS)))[1:end-1], \n        \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n# construct example DBInfo\ndbi = DBInfo(genome, \"Cas9_semirandom_noVCF\", Motif(\"Cas9\"))\n# finally gather all off-targets\nguides = Vector{String}()\nambig = gatherofftargets!(guides, dbi)\n\n\n\n\n\n","category":"function"},{"location":"api/#Align-gRNA-and-off-target","page":"API","title":"Align gRNA and off-target","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"isinclusive\nhamming\nlevenshtein\nAln\nalign","category":"page"},{"location":"api/#ARTEMIS.isinclusive","page":"API","title":"ARTEMIS.isinclusive","text":"isinclusive(x::S, y::S) where {S<:BioSymbol}\n\nCheck whether x contains all options of y or y contains all options of x. Can be used as replacement in place of BioSequences.iscompatible or BioSequences.isequal.\n\nExamples\n\njulia> isinclusive(DNA_N, DNA_A)\ntrue\n\njulia> isinclusive(DNA_W, DNA_R) # W is (A/T), R is (A/G)\nfalse\n\njulia> isinclusive(DNA_W, DNA_A)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#ARTEMIS.hamming","page":"API","title":"ARTEMIS.hamming","text":"hamming(s1::T, s2::K, ismatch = iscompatible) where {T <: BioSequence, K <: BioSequence}\n\nCheck Hamming distance between s1 and s2 using as matching definition ismatch. Should be faster than pairalign(HammingDistance(), s1, s2). Make sure inputs are of the  same length.\n\nExamples\n\njulia> hamming(dna\"ACGC\", dna\"AWRC\")\n1\n\n\n\n\n\n","category":"function"},{"location":"api/#ARTEMIS.levenshtein","page":"API","title":"ARTEMIS.levenshtein","text":"levenshtein(guide::T, ref::K, k::Int = 4,\n    ismatch::Function = iscompatible) where {T <: BioSequence, K <: BioSequence}\n\nCalculate Levenshtein distance bounded by k maximum edit distance with a twist for guide + off-target comparisons.\n\nLevenshtein distance is the minimum number of operations (consisting of insertions, deletions, substitutions of a single character) required to change one string into the other. guide input seqeunce is a gRNA sequence, ref input is reference sequence with expansion on the 3' end of k bases. This extension will not count toward the score, if it is not covered with aligned guide. Return k + 1, if distance is higher than k and terminate early. This function should be 10x faster than pairalign(LevenshteinDistance(), guide, ref, distance_only = true).\n\nNotice that guide and ref have to be oriented towards left side e.g. PAM-guide, and PAM-offtarget-extension! Take a look at the examples below to understand why.\n\nExamples\n\njulia> levenshtein(dna\"ATGA\", dna\"AGACCT\") # CCT as extension of the ref does not count towards the score in optimal alignment\n1\n\njulia> levenshtein(dna\"ATGATCG\", dna\"AGAAATCGATG\") # ATG does not count in optimal alignment ATG--ATCG/A-GAAATCG\n3\n\n\n\n\n\n","category":"function"},{"location":"api/#ARTEMIS.Aln","page":"API","title":"ARTEMIS.Aln","text":"struct Aln\n    guide::String\n    ref::String\n    dist::Int\nend\n\nSimple data structure to hold information on the optimal alignment. Therefore guide and ref may contain DNA_Gap as these are aligned sequences. Function align returns this object.\n\n\n\n\n\n","category":"type"},{"location":"api/#ARTEMIS.align","page":"API","title":"ARTEMIS.align","text":"align(guide::T, ref::K, k::Int = 4,\n    ismatch::Function = iscompatible) where {T <: BioSequence, K <: BioSequence}\n\nCalculate Levenshtein distance bounded by k maximum edit distance with a twist for guide + off-target comparisons, but return also the alignment as an Align object.\n\nLevenshtein distance is the minimum number of operations (consisting of insertions, deletions, substitutions of a single character) required to change one string into the other. guide input seqeunce is a gRNA sequence, ref input is reference sequence with expansion on the 3' end of k bases. This extension will not count toward the score, if it is not covered with aligned guide. Return k + 1, if distance is higher than k and terminate early.\n\nNotice that guide and ref have to be oriented towards left side e.g. PAM-guide, and PAM-offtarget-extension! Take a look at the examples below to understand why.\n\nExamples\n\njulia> align(dna\"ATGA\", dna\"AGACCT\") # CCT as extension of the ref does not count towards the score in optimal alignment\nAln(\"ATGA\", \"A-GA\", 1)\n\njulia> align(dna\"ATGATCG\", dna\"AGAAATCGATG\") # ATG does not count\nAln(\"ATG--ATCG\", \"A-GAAATCG\", 3)\n\n\n\n\n\n","category":"function"},{"location":"api/#Utils","page":"API","title":"Utils","text":"","category":"section"},{"location":"api/#gRNAs-and-kmers","page":"API","title":"gRNAs and kmers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"getseq\nas_kmers\nas_skipkmers\nall_kmers\nminkmersize","category":"page"},{"location":"api/#ARTEMIS.getseq","page":"API","title":"ARTEMIS.getseq","text":"getseq(n = 20, letters = ['A', 'C', 'G', 'T'])\n\nRandomize sequence of length n from letters.\n\n\n\n\n\n","category":"function"},{"location":"api/#ARTEMIS.as_kmers","page":"API","title":"ARTEMIS.as_kmers","text":"as_kmers(x::LongDNA{4}, kmer_size::Int)\n\nTransforms x into vector of kmers of size kmer_size.  All ambiguous bases will be expanded.\n\nExamples\n\njulia> as_kmers(dna\"ACTGG\", 4)\n2-element Vector{LongSequence{DNAAlphabet{4}}}:\n ACTG\n CTGG\n\n\n\n\n\n","category":"function"},{"location":"api/#ARTEMIS.as_skipkmers","page":"API","title":"ARTEMIS.as_skipkmers","text":"as_skipkmers(x::LongDNA{4}, kmer_size::Int)\n\nTransforms x into vector of skip-kmers of size kmer_size.  All ambiguous bases will be expanded.  Leftover-bases are ignored!\n\nExamples\n\njulia> as_skipkmers(dna\"ACTGG\", 2)\n2-element Vector{LongSequence{DNAAlphabet{4}}}:\n AC\n TG\n\n\n\n\n\n","category":"function"},{"location":"api/#ARTEMIS.all_kmers","page":"API","title":"ARTEMIS.all_kmers","text":"all_kmers(size = 4; alphabet = [DNA_A, DNA_C, DNA_G, DNA_T]\n\nMake a list of all possible kmers with givensize using bases in the alphabet. \n\nExamples\n\njulia> all_kmers(2; alphabet = [DNA_A, DNA_N])\n4-element Vector{LongSequence{DNAAlphabet{4}}}:\n AA\n AN\n NA\n NN\n\n\n\n\n\n","category":"function"},{"location":"api/#ARTEMIS.minkmersize","page":"API","title":"ARTEMIS.minkmersize","text":"minkmersize(len::Int = 20, d::Int = 4)\n\nPidgeon hole principle: minimum k-mer size that is required for two strings of size len to be aligned within distance of d.\n\nExamples\n\njulia> minkmersize(20, 3)\n5\n\njulia> minkmersize(20, 6)\n2\n\n\n\n\n\n","category":"function"},{"location":"api/#Persistence","page":"API","title":"Persistence","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"save\nload","category":"page"},{"location":"api/#ARTEMIS.save","page":"API","title":"ARTEMIS.save","text":"save(     object::Any,     destination::String)\n\nUses julia serializer to save the data to binary format. Read more about serialization. Notice that:\n\nThis function will overwrite destination! \nThis serialization is dependent on julia build! This means files can fail to work when reloaded across different julia builds.\n\n\n\n\n\n","category":"function"},{"location":"api/#ARTEMIS.load","page":"API","title":"ARTEMIS.load","text":"load(destination::String)\n\nLoad file saved with save function. This may not load properly files saved in other julia builds.\n\n\n\n\n\n","category":"function"},{"location":"api/#Alignment-free-filters-for-gRNAs","page":"API","title":"Alignment-free filters for gRNAs","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"build_hashDB\nsearch_hashDB","category":"page"},{"location":"api/#ARTEMIS.build_hashDB","page":"API","title":"ARTEMIS.build_hashDB","text":"build_hashDB(\n    name::String,\n    genomepath::String, \n    motif::Motif,\n    storagedir::String;\n    seed::UInt64 = UInt64(0x726b2b9d438b9d4d),\n    max_iterations::Int = 10,\n    max_count::Int = 10,\n    precision::DataType = UInt16)\n\nPrepare hashDB index for future searches using search_hashDB.\n\nArguments\n\nname - Your prefered name for this index for easier identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nmotif   - Motif deines what kind of gRNA to search for.\n\nstoragedir  - Folder path to the where index will be saved with name hashDB.bin.\n\nseed  - Optional. Seed is used during hashing for randomization.\n\nmax_iterations - When finding hashing structure for binary fuse filter it might fail sometimes,                     we will retry max_iterations number of times though.\n\nmax_count  - Above this count we put all unique off-targets into one bin.                 Put number here that is the minimum number of off-targets that you think is fine                for the distance of 1.\n\nprecision- The higher the precision the larger the database, but also chances for error decrease dramatically.              We support UInt8, UInt16, and UInt32.\n\nExamples\n\n# make a temporary directory\ntdir = tempname()\nhdb_path = joinpath(tdir, \"hashDB\")\nmkpath(hdb_path)\n\n# use ARTEMIS example genome\ngenome = joinpath(\n    vcat(\n        splitpath(dirname(pathof(ARTEMIS)))[1:end-1], \n        \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# finally, build a hashDB\nbuild_hashDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 1, ambig_max = 0), \n    hdb_path)\n\n\n\n\n\n","category":"function"},{"location":"api/#ARTEMIS.search_hashDB","page":"API","title":"ARTEMIS.search_hashDB","text":"search_hashDB(\n    storagedir::String,\n    guides::Vector{LongDNA{4}},\n    right::Bool)\n\nEstimate off-target counts for guides using hashDB stored at storagedir.\n\nProbabilistic filter offers a guarantee that it will always be correct when a sequence  is in the set (no false negatives), but may overestimate that a sequence is in the set  while it is not (false positive) with low probability. If both columns in the results are 0,  it is guaranteed this gRNA has no off-targets in the genome!\n\nAlso, maximum count for each off-target in the database is capped, to max_count specified during building of hashDB. This means  that counts larger than max_count are no longer estimating correctly. Its likely you would not care for those guides anyhow.\n\nright argument specifies whether the databse should be checked in direction from  unique off-targets which occur once to increasingly more occuring off-targets up until  max_count is reached, which may result in assuming lower than real off-target counts  (underestimate) for some of the sequences, however this approach will not reject any  gRNAs that should not be rejected and is suitable for filtering of gRNAs we do not need.  Left (right = false, or hight-counts to low-counts) approach is also supported,  which can be used for ordering of gRNAs to the best of database ability.  Left approach may overestimate counts for some gRNAs. When gRNA is reported as  off-target free it is also guaranteed to be true in both cases (low-to-high and high-to-low).\n\nExamples\n\n# prepare libs\nusing ARTEMIS, BioSequences\n\n# make a temporary directory\ntdir = tempname()\nhdb_path = joinpath(tdir, \"hashDB\")\nmkpath(hdb_path)\n\n# use ARTEMIS example genome\ncoh_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(vcat(coh_path, \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a hashDB\nbuild_hashDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 1, ambig_max = 0), \n    hdb_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(coh_path, \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n\n# finally, get results!\nhdb_res = search_hashDB(hdb_path, guides, false)\n\n\n\n\n\n","category":"function"},{"location":"api/#Find-all-off-targets","page":"API","title":"Find all off-targets","text":"","category":"section"},{"location":"api/#Prefix-Suffix-partial-alignment","page":"API","title":"Prefix-Suffix partial alignment","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"build_linearDB\nsearch_linearDB\n\nbuild_motifDB\nsearch_motifDB","category":"page"},{"location":"api/#ARTEMIS.build_linearDB","page":"API","title":"ARTEMIS.build_linearDB","text":"build_linearDB(\n    name::String,\n    genomepath::String,\n    motif::Motif,\n    storagedir::String,\n    prefix_len::Int = 7)\n\nPrepare linearDB index for future searches using search_linearDB.\n\nWill return a path to the database location, same as storagedir. When this database is used for the guide off-target scan it is similar  to linear in performance, hence the name. There is an optimization that  if the alignment becomes imposible against the prefix we don't search the off-targets grouped inside the prefix. Therefore, it is advantageous to select much larger prefix than maximum  search distance, however in that case number of files also grows. For example, if interested with searches within distance 4, preferably use prefix length of  7 or 8.\n\nArguments\n\nname - Your prefered name for this index for easier identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nmotif   - Motif deines what kind of gRNA to search for.\n\nstoragedir  - Folder path to the where index will be saved with name linearDB.bin and many prefix files.\n\nprefix_len  - Size of the prefix by which off-targets are indexed. Prefix of 8 or larger will be the fastest,                 however it will also result in large number of files.\n\nExamples\n\n# make a temporary directory\ntdir = tempname()\nldb_path = joinpath(tdir, \"linearDB\")\nmkpath(ldb_path)\n\n# use ARTEMIS example genome\ngenome = joinpath(\n    vcat(\n        splitpath(dirname(pathof(ARTEMIS)))[1:end-1], \n        \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# finally, build a linearDB\nbuild_linearDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 1, ambig_max = 0), \n    ldb_path)\n\n\n\n\n\n","category":"function"},{"location":"api/#ARTEMIS.search_linearDB","page":"API","title":"ARTEMIS.search_linearDB","text":"search_linearDB(\n    storagedir::String, \n    guides::Vector{LongDNA{4}}, \n    dist::Int = 4; \n    detail::String = \"\")\n\nFind all off-targets for guides within distance of dist using linearDB located at storagedir.\n\nAssumes your guides do not contain PAM, and are all in the same direction as  you would order from the lab e.g.:\n\n5' - ...ACGTCATCG NGG - 3'  -> will be input: ...ACGTCATCG\n     guide        PAM\n    \n3' - CCN GGGCATGCT... - 5'  -> will be input: ...AGCATGCCC\n     PAM guide\n\nArguments\n\ndist - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.  \n\ndetail - Path and name for the output file. This search will create intermediate  files which will have same name as detail, but with a sequence prefix. Final file will contain all those intermediate files. Leave detail empty if you are only  interested in off-target counts returned by the linearDB. \n\nExamples\n\n# make a temporary directory\ntdir = tempname()\nldb_path = joinpath(tdir, \"linearDB\")\nmkpath(ldb_path)\n\n# use ARTEMIS example genome\ncoh_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(\n    vcat(\n        coh_path, \n        \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a linearDB\nbuild_linearDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 3, ambig_max = 0), \n    ldb_path)\n\n# load up example gRNAs\nusing BioSequences\nguides_s = Set(readlines(joinpath(vcat(coh_path, \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, get results!\nldb_res = search_linearDB(ldb_path, guides, 3)\n\n\n\n\n\n","category":"function"},{"location":"api/#ARTEMIS.build_motifDB","page":"API","title":"ARTEMIS.build_motifDB","text":"build_motifDB(\n    name::String,\n    genomepath::String,\n    motif::Motif,\n    storagedir::String,\n    prefix_len::Int = 7;\n    skipmer_size::Int = Int(floor(length_noPAM(motif) / (motif.distance + 3))))\n\nPrepare motifDB index for future searches using search_motifDB.\n\nWill return a path to the database location, same as storagedir. When this database is used for the guide off-target scan it is similar  to search_linearDB, however additional filter is applied on top of  prefix filtering. Suffixes are used for next filter, similarly to  pidgeon hole principle - depending on the size of the skipkmer skipkmer_size. For example, Cas9 off-target within distance 4 (d) might be 20bp long. We skip prefix_len of 7, and are left with 13bp which can be split into 3  skipmers (r) of size 4, 1bp will be left unused. However when searching within  distance of 4 and for prefix where initial alignment was of distance 3 (m) and adjustment paramter is 0 (a). We are obliged to find at least k - (d - m + a)  which is 3 - (4 - 3 + 0) = 2 this many skimpers inside the off-targets. \n\nThere exist also another approach which builds on the idea that it might be more efficient to find at least two kmers of smaller size (named 01*0 seed) rather than one larger kmer  (pidgeon hole principle). You can use the adjust option for that during search_linearDB step.\n\nBe sure to understand implications of using motifDB as using wrong parameters  on skipmer_size might result in leaky filtering in relation to the asumed  distance dist and adjustment adjust during search step in search_motifDB.\n\nArguments\n\nname - Your prefered name for this index for easier identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nmotif   - Motif deines what kind of gRNA to search for.\n\nstoragedir  - Folder path to the where index will be saved with name linearDB.bin and many prefix files.\n\nprefix_len  - Size of the prefix by which off-targets are indexed. Prefix of 8 or larger will be the fastest,                 however it will also result in large number of files. \n\nskipmer_size - Size of the skipmer as described above. Be carefull when setting this too large!\n\nExamples\n\n# make a temporary directory\ntdir = tempname()\nmdb_path = joinpath(tdir, \"motifDB\")\nmkpath(mdb_path)\n\n# use ARTEMIS example genome\ngenome = joinpath(\n    vcat(\n        splitpath(dirname(pathof(ARTEMIS)))[1:end-1], \n        \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# finally, build a motifDB\nbuild_motifDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 3, ambig_max = 0), \n    mdb_path)\n\n\n\n\n\n","category":"function"},{"location":"api/#ARTEMIS.search_motifDB","page":"API","title":"ARTEMIS.search_motifDB","text":"search_motifDB(\n    storagedir::String, \n    guides::Vector{LongDNA{4}}, \n    dist::Int = 4; \n    detail::String = \"\",\n    adjust::Int = 0)\n\nFind all off-targets for guides within distance of dist using motifDB located at storagedir.\n\nAssumes your guides do not contain PAM, and are all in the same direction as  you would order from the lab e.g.:\n\n5' - ...ACGTCATCG NGG - 3'  -> will be input: ...ACGTCATCG\n     guide        PAM\n    \n3' - CCN GGGCATGCT... - 5'  -> will be input: ...AGCATGCCC\n     PAM guide\n\nArguments\n\ndist - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.  \n\ndetail - Path and name for the output file. This search will create intermediate  files which will have same name as detail, but with a sequence prefix. Final file will contain all those intermediate files. Leave detail empty if you are only  interested in off-target counts returned by the motifDB. \n\nadjust - This will be crutial parameter for tightening second layer of filtering after,  the initial prefix alignment. For example, Cas9 off-target within distance 4 (d) might be 20bp long. We skip prefix_len of 7, and are left with 13bp which can be split into 3 skipmers (r) of size 4,  1bp will be left unused. However when searching within distance of 4 and for prefix where initial  alignment was of distance 3 (m) and adjustment paramter is 0 (a). We are obliged to find at least  k - (d - m + a) which is 3 - (4 - 3 + 0) = 2 this many skimpers inside the off-targets. \n\nExamples\n\n# make a temporary directory\ntdir = tempname()\nmdb_path = joinpath(tdir, \"motifDB\")\nmkpath(mdb_path)\n\n# use ARTEMIS example genome\ncoh_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(\n    vcat(\n        coh_path, \n        \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a motifDB\nbuild_motifDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 3, ambig_max = 0), \n    mdb_path)\n\n# load up example gRNAs\nusing BioSequences\nguides_s = Set(readlines(joinpath(vcat(coh_path, \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, get results!\nmdb_res = search_motifDB(mdb_path, guides, 3)\n\n\n\n\n\n","category":"function"},{"location":"api/#Vantage-Point-tree","page":"API","title":"Vantage-Point tree","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"build_treeDB\ninspect_treeDB\nsearch_treeDB","category":"page"},{"location":"api/#ARTEMIS.build_treeDB","page":"API","title":"ARTEMIS.build_treeDB","text":"build_treeDB(\n    name::String,\n    genomepath::String,\n    motif::Motif,\n    storagedir::String,\n    prefix_len::Int = 7)\n\nBuild a Vantage Point tree DB of offtargets for the given motif, DB groups off-targets by their prefixes, each prefix has its own Vantage Point tree.\n\nWill return a path to the database location, same as storagedir.\n\nThere is an optimization that if the alignment becomes imposible against the prefix we don't search the off-targets grouped inside the prefix. Therefore it is advantageous to select larger prefix than maximum  search distance, however in that case number of files also grows.\n\nArguments\n\nname - Your prefered name for this index for easier identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nmotif   - Motif deines what kind of gRNA to search for.\n\nstoragedir  - Folder path to the where index will be saved with name linearDB.bin and many prefix files.\n\nprefix_len  - Size of the prefix by which off-targets are indexed. Prefix of 8 or larger will be the fastest,                 however it will also result in large number of files. \n\nExamples\n\n# make a temporary directory\ntdir = tempname()\ntdb_path = joinpath(tdir, \"treeDB\")\nmkpath(tdb_path)\n\n# use ARTEMIS example genome\ngenome = joinpath(\n    vcat(\n        splitpath(dirname(pathof(ARTEMIS)))[1:end-1], \n        \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# finally, build a motifDB\nbuild_treeDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 3, ambig_max = 0), \n    tdb_path)\n\n\n\n\n\n","category":"function"},{"location":"api/#ARTEMIS.inspect_treeDB","page":"API","title":"ARTEMIS.inspect_treeDB","text":"inspect_treeDB(\n    storagedir::String; \n    levels::Int = 5, \n    inspect_prefix::String = \"\")\n\nSee small part of the full vantage point tree of the treeDB.\n\nTreeDB can be split based on the distance to the radius (r)  into inside (left <= r) and right (outside > r) nodes.\n\nExamples\n\n# make a temporary directory\ntdir = tempname()\ntdb_path = joinpath(tdir, \"treeDB\")\nmkpath(tdb_path)\n\n# use ARTEMIS example genome\ngenome = joinpath(\n    vcat(\n        splitpath(dirname(pathof(ARTEMIS)))[1:end-1], \n        \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# finally, build a motifDB\nbuild_treeDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 3, ambig_max = 0), \n    tdb_path)\n\n# finally, view some part of the database!\ninspect_treeDB(tdb_path; inspect_prefix = \"CCGTCGC\")\n\n\n\n\n\n","category":"function"},{"location":"api/#ARTEMIS.search_treeDB","page":"API","title":"ARTEMIS.search_treeDB","text":"search_treeDB(\n    storagedir::String, \n    guides::Vector{LongDNA{4}}, \n    dist::Int = 4; \n    detail::String = \"\")\n\nSearch previously build treeDB database for the off-targets of the guides. \n\nAssumes your guides do not contain PAM, and are all in the same direction as  you would order from the lab e.g.:\n\n5' - ...ACGTCATCG NGG - 3'  -> will be input: ...ACGTCATCG\n     guide        PAM\n\n3' - CCN GGGCATGCT... - 5'  -> will be input: ...AGCATGCCC\n     PAM guide\n\nArguments\n\ndist - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.  \n\ndetail - Path and name for the output file. This search will create intermediate  files which will have same name as detail, but with a sequence prefix. Final file will contain all those intermediate files. Leave detail empty if you are only  interested in off-target counts returned by the treeDB. \n\nExamples\n\n# make a temporary directory\ntdir = tempname()\ntdb_path = joinpath(tdir, \"treeDB\")\nmkpath(tdb_path)\n\n# use ARTEMIS example genome\ncoh_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(\n    vcat(\n        coh_path, \n        \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a motifDB\nbuild_treeDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 3, ambig_max = 0), \n    tdb_path)\n\n# load up example gRNAs\nusing BioSequences\nguides_s = Set(readlines(joinpath(vcat(coh_path, \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, get results!\ntdb_res = search_treeDB(tdb_path, guides, 3)\n\n\n\n\n\n","category":"function"},{"location":"#ARTEMIS","page":"General","title":"ARTEMIS","text":"","category":"section"},{"location":"#About","page":"General","title":"About","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"Julia framework related to CRISPR off-targets:","category":"page"},{"location":"","page":"General","title":"General","text":"fast alignment alghoritms optimized for CRISPR\nfind quickly all off-targets on the arbitrairly large genomes, with arbitrary distances, and ambiogous bases support\nVCF support - with multiple overlapping SNPs\nnear-instant alignment-free off-target filtering\npruning of off-targets by their location (remove overlapping, competing off-targets)\nextensively tested","category":"page"},{"location":"","page":"General","title":"General","text":"We have chosen Julia because it is possible to quickly prototype new alghoritms and not compromise the speed, but also, Julia's syntax is python like and it is easy to jump right into coding.","category":"page"},{"location":"","page":"General","title":"General","text":"Documentation is available here.","category":"page"},{"location":"#Requirements","page":"General","title":"Requirements","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"Some of the alghoritms generate as many files as there are prefixes (e.g. for prefix 7 - this will make 4^7 - 16384) when using '–detail' option. This strategy allows us to operate the searches independently on multiple cores and not get throtled when querying large number of the guides. However, some systems have artificial limits on the number of open files, for example in ubuntu 'ulimit -n' will show the limit. Increase the limits, if it creates problems for you.\nWhen using many cores for building the indexes - you have to have around ~1GB of RAM per thread.","category":"page"},{"location":"#Build-application","page":"General","title":"Build application","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"It is possible to build ARTEMIS into standalone application - which includes all dependencies and Julia into one compiled software. This is recommended method for using of ARTEMIS when you are not a developer. If you know how to code in Julia, you might make use of the whole framework using ARTEMIS as a package.","category":"page"},{"location":"","page":"General","title":"General","text":"To build a standalone application run ./build_standalone.sh script from the main directory. Script will produce binary in a new folder outside the main directory. Then you can run from inside that folder ./bin/ARTEMIS --help. To learn about possible indexes run ./bin/ARTEMIS build --help and to use existing index check out ./bin/ARTEMIS search --help. It is possible to skip testing + precompile step to speed up the build process with ./build_standalone.sh --noprecompile.","category":"page"},{"location":"","page":"General","title":"General","text":"You can alternatively download latest release from the releases page on the github.","category":"page"},{"location":"","page":"General","title":"General","text":"When using application as self-contained, you can control number of cores by setting JULIA_NUM_THREADS environment variable.","category":"page"},{"location":"#No-build-application","page":"General","title":"No-build application","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"Run ARTEMIS as an application without compilation. From the directory of the package run:","category":"page"},{"location":"","page":"General","title":"General","text":"julia --threads 4 --project=\".\" ./src/ARTEMIS.jl --help","category":"page"},{"location":"#Quick-Use","page":"General","title":"Quick Use","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"If you would like to filter gRNAs to only those that are most likely off-target free you want to use hashDB. ","category":"page"},{"location":"","page":"General","title":"General","text":"For search of off-targets you have a couple of options:","category":"page"},{"location":"","page":"General","title":"General","text":"linearDB - most rigorously tested\ntreeDB - will work best for very long gRNAs\nmotifDB - the fastest","category":"page"},{"location":"","page":"General","title":"General","text":"For VCF file support use vcfDB.  For use of the framework as a Julia package consult the documentation - Public Interface section.","category":"page"},{"location":"#LICENSE","page":"General","title":"LICENSE","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"Copyright (C) 2021  Kornel Labun","category":"page"},{"location":"","page":"General","title":"General","text":"This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.","category":"page"},{"location":"","page":"General","title":"General","text":"This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.","category":"page"},{"location":"","page":"General","title":"General","text":"You should have received a copy of the GNU Affero General Public License along with this program.  If not, see https://www.gnu.org/licenses/.","category":"page"}]
}
